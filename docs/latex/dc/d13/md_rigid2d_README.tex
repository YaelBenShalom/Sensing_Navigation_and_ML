Author\+: Yael Ben Shalom\hypertarget{md_rigid2d_README_autotoc_md25}{}\doxysection{Package Summary}\label{md_rigid2d_README_autotoc_md25}
A library for handling transformations in SE(2).\hypertarget{md_rigid2d_README_autotoc_md26}{}\doxysection{Nodes and launchfiles}\label{md_rigid2d_README_autotoc_md26}
This library contains several nodes and launchfiles\+:


\begin{DoxyItemize}
\item {\bfseries{odometer node}} -\/ Publishes Odometry messages for differential drive robot based on wheel joint states.
\item {\bfseries{fake\+\_\+turtle node}} -\/ A kinematic simulation of a differential drive robot using the Diff\+Drive class.
\item {\bfseries{fake\+\_\+turtle\+\_\+odom launchfile}} -\/ Launch file for making a turtle move in Rviz using turtlebot3\+\_\+teleop. Run {\ttfamily roslaunch rigid2d fake\+\_\+turtle\+\_\+odom.\+launch} to launch the turtle in Rviz, and move it using the {\ttfamily w}, {\ttfamily d}, {\ttfamily x}, {\ttfamily a} letters on your keyboard.


\end{DoxyItemize}\hypertarget{md_rigid2d_README_autotoc_md27}{}\doxysection{Conceptual Questions}\label{md_rigid2d_README_autotoc_md27}

\begin{DoxyEnumerate}
\item What is the difference between a class and a struct in C++?

The difference between a class and struct in C++ is the default accessibility of member variables and methods. In a struct they are public, and in a class they are private.
\item Why is Vector2D a struct and Transform2D Class (refer to at least 2 specific C++ core guidelines in your answer)?

In a struct, the members can vary independently, and they are public. For example, the variables x and y in the Vector2D are independent and public, so we can define and refer to them from outside the struct, and we can change them independently of each other. On the other hand, the members in Transform2D are private, so we can\textquotesingle{}t refer or change them from outside the class. in order to refer them, I defined x, y, and theta function to output the variables values.
\item Why are some of the constructors in Transform2D explicit (refer to a specific C++ core guideline in your answer)?

Some constructors in Transform2D are explicit To avoid unintended conversions. In our case, it converts to Transform2D explicitly.
\item We need to be able to normalize Vector2D objects (i.\+e., find the unit vector in the direction of a given Vector2D)\+:
\begin{DoxyItemize}
\item Propose three different designs for implementing the $\sim$normalize$\sim$ functionality
\item Discuss the pros and cons of each proposed method, in light of the C++ Core Guidelines.
\item Which of the methods would you implement and why?
\end{DoxyItemize}

One implementation of the normalize is to implement the function inside the Vector2D struct (Vector2\+D\+::normalize()). Second method is to define another struct for normalized vectors, and define the function normalize as part of this struct (Normal\+Vector2\+D\+::normalize()). Third method is to define the function outside of any class or struct. I would implement the function normalize as part of the Vector2D struct (Vector2\+D\+::normalize()), because it is only used on Vector2D type variables, and as part of a struct it is a public function and can be used outside of the struct.
\item Why is Transform2\+D\+::inv() declared const while Transform2\+D\+::operator$\ast$=() is not (Refer to C++ core guidelines in your answer)?
\begin{DoxyItemize}
\item Refer to \mbox{[}\mbox{[}\href{https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\#con-constants-and-immutability}{\texttt{ https\+://isocpp.\+github.\+io/\+Cpp\+Core\+Guidelines/\+Cpp\+Core\+Guidelines\#con-\/constants-\/and-\/immutability}}\mbox{]}\mbox{[}C++ Core Guidelines (Constants and Immutability)\mbox{]}\mbox{]} in your answer.
\end{DoxyItemize}

By default, it is better to make member functions const, unless it changes the object’s observable state. This gives a more precise statement of design intent, better readability, more errors caught by the compiler, and sometimes more optimization opportunities. In the Transform2\+D\+::inv() function, we do not change object’s observable state and we return a new internal variable, therefore it is const. On the other hand, in the Transform2\+D\+::operator$\ast$=() function, we do change the object’s observable state and return the new state, and therefore it is non-\/const. 
\end{DoxyEnumerate}